"""
Serveur MCP pour Ultravox
Permet à Claude d'accéder aux outils Ultravox via MCP
"""

import os
import httpx
from typing import Optional
from fastmcp import FastMCP
from dotenv import load_dotenv

# Charge la variable d'environnement ULTRAVOX_API_KEY depuis un fichier .env
load_dotenv()

# Crée le serveur MCP appelé "ultravox"
mcp = FastMCP("ultravox")

# Récupère la clé API depuis la variable d'environnement
ULTRAVOX_API_KEY = os.getenv("ULTRAVOX_API_KEY")
if not ULTRAVOX_API_KEY:
    raise ValueError(
        "❌ ERREUR : La clé API Ultravox n'est pas définie. "
        "Définis la variable d'environnement ULTRAVOX_API_KEY."
    )

# URL de base de l'API Ultravox
ULTRAVOX_API_BASE = "https://api.ultravox.ai/api"

# Headers HTTP pour les requêtes
HEADERS = {
    "X-API-Key": ULTRAVOX_API_KEY,
    "Content-Type": "application/json",
}


@mcp.tool()
def list_calls(limit: int = 20) -> dict:
    """
    Récupère la liste des appels Ultravox.
    
    Args:
        limit: Nombre d''appels à retourner (par défaut 20)
    
    Returns:
        Un dictionnaire contenant la liste des appels avec les infos principales
    """
    try:
        with httpx.Client() as client:
            response = client.get(
                f"{ULTRAVOX_API_BASE}/calls",
                headers=HEADERS,
                params={"limit": limit},
                timeout=10.0
            )
        
        # Gère les erreurs API
        if response.status_code == 401:
            return {
                "error": "Authentification échouée (401)",
                "message": "Vérifie ta clé ULTRAVOX_API_KEY. Elle est probablement incorrecte."
            }
        elif response.status_code == 429:
            return {
                "error": "Trop de requêtes (429)",
                "message": "Tu as fait trop de requêtes trop vite. Attends un peu et réessaie."
            }
        elif response.status_code == 500:
            return {
                "error": "Erreur serveur Ultravox (500)",
                "message": "Le serveur Ultravox a un problème. Réessaie dans quelques instants."
            }
        elif response.status_code >= 400:
            return {
                "error": f"Erreur API ({response.status_code})",
                "details": response.text
            }
        
        data = response.json()
        
        # L''API Ultravox retourne les résultats dans "results" (avec pagination)
        # Fallback sur "data" si la structure change
        calls = data.get("results", data.get("data", data)) if isinstance(data, dict) else data
        
        # Formate les appels pour qu''ils soient lisibles
        if not isinstance(calls, list):
            return {
                "error": "Format inattendu",
                "raw_response": str(data)[:500]
            }
        
        if len(calls) == 0:
            return {
                "success": True,
                "count": 0,
                "message": "Aucun appel trouvé. C''est normal si votre compte ne contient pas d''appels.",
                "calls": []
            }
        
        formatted_calls = []
        for call in calls[:limit]:
            formatted_calls.append({
                "id": call.get("id", "N/A"),
                "created_at": call.get("createdAt", call.get("created_at", "N/A")),
                "duration_minutes": round(call.get("duration", 0) / 60, 2) if call.get("duration") else 0,
                "agent": call.get("agent", call.get("agent_name", "N/A")),
                "status": call.get("status", "N/A"),
                "participant": call.get("participant", call.get("customer", "N/A")),
            })
        
        return {
            "success": True,
            "count": len(formatted_calls),
            "calls": formatted_calls
        }
    
    except httpx.TimeoutException:
        return {
            "error": "Timeout",
            "message": "La requête a dépassé le délai d''attente. Le serveur Ultravox ne répond pas."
        }
    except httpx.RequestError as e:
        return {
            "error": "Erreur réseau",
            "message": f"Impossible de contacter l''API Ultravox : {str(e)}"
        }
    except Exception as e:
        return {
            "error": "Erreur inattendue",
            "message": str(e)
        }


@mcp.tool()
def get_call(call_id: str) -> dict:
    """
    Récupère les détails complets d''un appel spécifique.
    
    Args:
        call_id: L''ID de l''appel à récupérer
    
    Returns:
        Un dictionnaire contenant les infos détaillées de l''appel
    """
    if not call_id:
        return {
            "error": "Paramètre manquant",
            "message": "Tu dois fournir un call_id"
        }
    
    try:
        with httpx.Client() as client:
            response = client.get(
                f"{ULTRAVOX_API_BASE}/calls/{call_id}",
                headers=HEADERS,
                timeout=10.0
            )
        
        # Gère les erreurs API
        if response.status_code == 401:
            return {
                "error": "Authentification échouée (401)",
                "message": "Vérifie ta clé ULTRAVOX_API_KEY."
            }
        elif response.status_code == 404:
            return {
                "error": "Appel non trouvé (404)",
                "message": f"Aucun appel ne correspond à l''ID: {call_id}"
            }
        elif response.status_code == 429:
            return {
                "error": "Trop de requêtes (429)",
                "message": "Attends un peu et réessaie."
            }
        elif response.status_code >= 400:
            return {
                "error": f"Erreur API ({response.status_code})",
                "details": response.text
            }
        
        call = response.json()
        
        # Formate les infos de l''appel
        return {
            "success": True,
            "call": {
                "id": call.get("id", "N/A"),
                "created_at": call.get("createdAt", call.get("created_at", "N/A")),
                "duration_seconds": call.get("duration", 0),
                "duration_minutes": round(call.get("duration", 0) / 60, 2) if call.get("duration") else 0,
                "agent": call.get("agent", call.get("agent_name", "N/A")),
                "status": call.get("status", "N/A"),
                "participant": call.get("participant", call.get("customer", "N/A")),
                "transcript": call.get("transcript", "N/A"),
                "recording_url": call.get("recording_url", call.get("recordingUrl", "N/A")),
                "raw_data": call
            }
        }
    
    except httpx.TimeoutException:
        return {
            "error": "Timeout",
            "message": "La requête a dépassé le délai d''attente."
        }
    except httpx.RequestError as e:
        return {
            "error": "Erreur réseau",
            "message": f"Impossible de contacter l''API Ultravox : {str(e)}"
        }
    except Exception as e:
        return {
            "error": "Erreur inattendue",
            "message": str(e)
        }


@mcp.tool()
def list_voices() -> dict:
    """
    Récupère la liste des voix disponibles sur Ultravox.
    
    Returns:
        Un dictionnaire contenant les voix disponibles avec leurs IDs et noms
    """
    try:
        with httpx.Client() as client:
            response = client.get(
                f"{ULTRAVOX_API_BASE}/voices",
                headers=HEADERS,
                timeout=10.0
            )
        
        # Gère les erreurs API
        if response.status_code == 401:
            return {
                "error": "Authentification échouée (401)",
                "message": "Vérifie ta clé ULTRAVOX_API_KEY."
            }
        elif response.status_code == 429:
            return {
                "error": "Trop de requêtes (429)",
                "message": "Attends un peu et réessaie."
            }
        elif response.status_code >= 400:
            return {
                "error": f"Erreur API ({response.status_code})",
                "details": response.text
            }
        
        data = response.json()
        
        # L''API Ultravox retourne les voix dans "results" (avec pagination)
        # Fallback sur "data" si la structure change
        voices = data.get("results", data.get("data", data)) if isinstance(data, dict) else data
        
        if not isinstance(voices, list):
            return {
                "error": "Format inattendu",
                "raw_response": str(data)[:500]
            }
        
        if len(voices) == 0:
            return {
                "success": True,
                "count": 0,
                "message": "Aucune voix trouvée.",
                "voices": []
            }
        
        # Formate les voix pour qu''elles soient lisibles
        formatted_voices = []
        for voice in voices:
            formatted_voices.append({
                "id": voice.get("id", "N/A"),
                "name": voice.get("name", voice.get("voiceName", "N/A")),
                "language": voice.get("language", "N/A"),
                "description": voice.get("description", ""),
            })
        
        return {
            "success": True,
            "count": len(formatted_voices),
            "voices": formatted_voices
        }
    
    except httpx.TimeoutException:
        return {
            "error": "Timeout",
            "message": "La requête a dépassé le délai d''attente."
        }
    except httpx.RequestError as e:
        return {
            "error": "Erreur réseau",
            "message": f"Impossible de contacter l''API Ultravox : {str(e)}"
        }
    except Exception as e:
        return {
            "error": "Erreur inattendue",
            "message": str(e)
        }


if __name__ == "__main__":
    # Lance le serveur MCP
    mcp.run()
